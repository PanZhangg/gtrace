#include <stdio.h>
#include <stdlib.h>

#include <unistd.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <arpa/inet.h>
#include <netdb.h>
#include <netinet/ip_icmp.h>
#include <netinet/udp.h>
#include <netinet/tcp.h>
#include <sys/time.h>
#include <errno.h>
#include <string.h>
#include "pktcraft.h"

unsigned short static
checksum(unsigned short *buf, int len)
{
    int nleft = len;
    unsigned short *w = buf;
    unsigned short answer;
    int sum = 0;

    while (nleft > 1)  {
        sum += *w++;
        nleft -= 2;
    }

    if (nleft == 1) {
        sum += htons(*(u_char *)w << 8);
    }

    sum = (sum >> 16) + (sum & 0xffff);
    sum += (sum >> 16);
    answer = ~sum;
    return (answer);
}

int
addrconvert(char *address, struct in_addr *inaddr)
{
    struct hostent *he;
    if (inet_aton(address, inaddr) == 1) {
        return 1;
    }
    he = gethostbyname(address);
    if (he != NULL) {
        *inaddr = *((struct in_addr *)he->h_addr_list[0]);
        return 1;
    } else {
        return 0;
    }
}


void *
gentcppackethdr(int srcPort, int destPort, int len, size_t *actualLen)
{
    void *buf;
    struct tcphdr *tcp;
    int minLen;
    size_t actLen;

    minLen = sizeof(struct tcphdr);
    if (len < minLen) {
        actLen = minLen;
    } else {
        actLen = len;
    }
    /*the caller must free this buffer */
    buf = malloc(actLen);
    if (buf == NULL) {
        fprintf(stderr, "PktTCPCraft: Alloc %d bytes memory failed\n",(int)actLen);
        return NULL;
    }
    tcp = (struct tcphdr *)buf;
    bzero(tcp, sizeof(struct tcphdr));
    tcp->source = htons(srcPort);
    tcp->dest = htons(destPort);
    tcp->seq = random();
    tcp->ack_seq = 0;
    tcp->doff = 5;

    /*fill in the data area */
    if (actLen > minLen) {
        memcpy(buf + minLen, "TCP packet generated by PktCraft", actLen - minLen);
    }

    if (actualLen) {
        *actualLen = actLen;
    }
    return buf;
}

void *
genudppackethdr(int srcPort, int destPort, int len, size_t *actualLen)
{
    void *buf;
    struct udphdr *udp;
    int minLen;
    size_t actLen;

    minLen = sizeof(struct udphdr);
    if (len < minLen) {
        actLen = minLen;
    } else {
        actLen = len;
    }
    /*the caller must free this buffer */
    buf = malloc(actLen);
    if (buf == NULL) {
        fprintf(stderr, "PktUDPCraft: Alloc %d bytes memory failed\n",(int) actLen);
        return NULL;
    }
    udp = (struct udphdr *)buf;
    udp->source = htons(srcPort);
    udp->dest = htons(destPort);
    udp->len = htons(actLen);
    udp->check = 0;

    /*fill in the data area */
    if (actLen > minLen) {
        memcpy(buf + minLen, "UDP packet generated by IPGen", actLen - minLen);
    }

    if (actualLen) {
        *actualLen = actLen;
    }
    return buf;
}

void *
genicmppackethdr(int len, size_t *actualLen)
{
    void *buf;
    struct icmphdr *icmp;
    static unsigned int seq = 1;
    int minLen;
    size_t actLen;

    minLen = sizeof(struct icmphdr) + sizeof(struct timeval);
    if (len < minLen) {
        actLen = minLen;
    } else {
        actLen = len;
    }
    /*the caller must free this buffer */
    buf = malloc(actLen);
    if (buf == NULL) {
        fprintf(stderr, "PktICMPCraft: Alloc %d bytes memory failed\n", (int)actLen);
        return NULL;
    }
    memset(buf, 0, actLen);
    icmp = (struct icmphdr *)buf;
    icmp->type = ICMP_ECHO;
    icmp->code = 0;
    icmp->un.echo.id = getpid();
    icmp->un.echo.sequence = htons(seq++);
    gettimeofday((struct timeval *)(icmp + 1), NULL);
    icmp->checksum = checksum((unsigned short *)icmp, actLen);
    if (actualLen) {
        *actualLen = actLen;
    }
    return buf;
}

void *
genippackethdr(void *content, size_t contentLen,
                    struct in_addr sIP, struct in_addr dIP, unsigned char proto)
{
    void *buf;
    size_t len;
    static short id = 0;
    struct ip *ip;

    len = sizeof(struct ip) + contentLen;
    /*the caller must free this buffer */
    buf = malloc(len);
    if (buf == NULL) {
        fprintf(stderr, "PktIPCraft: Alloc %d bytes memory failed\n", (int)len);
        return NULL;
    }
    if (content) {
        memcpy(buf + sizeof(struct ip), content, contentLen);
    }

    ip = (struct ip *)buf;
    ip->ip_v = IPVERSION;
    ip->ip_hl = sizeof(struct ip) >> 2;
    ip->ip_tos = 0;
    ip->ip_len = htons(len);
    ip->ip_id = htons(id++);
    ip->ip_off = 0;
    ip->ip_ttl = IPDEFTTL;
    ip->ip_p = proto;
    ip->ip_sum = 0;
    ip->ip_src = sIP;
    ip->ip_dst = dIP;

    return buf;
}
